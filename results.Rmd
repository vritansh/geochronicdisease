# Results

```{r}
#All Imports here
library(dplyr)
library(tidyr)
library(tibble)
library(ggplot2)
library(choroplethr)
library(tidyverse)
library(mapview)
library(lubridate)
library(geofacet)
library(plotly)
options(warn=-1)
```

```{r}
#Preprocessing and converting to minifiles that will be used throughout to plot
data = read.csv("ChronicDiseases.csv")

```



```{r}
clean_dataset <- function(data) {
#Get only useful columns, Drop the ones not required
data <-dplyr::select(data, -c('StratificationCategoryID2', 'StratificationCategoryID3','StratificationID2','StratificationID3', 'StratificationCategory2','Stratification2','StratificationCategory3','Stratification3','Response','LowConfidenceLimit', 'HighConfidenceLimit', 'ResponseID', 'DataValueUnit', 'DataValueAlt'))
          
          #Consider data only for 2018-2020
          df <- data[data$YearStart %in% c('2018', '2019', '2020'), ]
          
          #Select only number
          df <- df[df$DataValueType %in% c('Number'), ]
          
          #Preprocess data here 
          df$DataValue[df$DataValue==""] <- 0
          
          #replace data with a numerical value
          df$DataValue <- as.numeric(df$DataValue)
          
          #Add code for NVSS
          df <- df[df$DataSource %in% c('NVSS'), ]

          #Not required as we're not dealing with lat long values currently    
          #Provide reference for the X and Y 
          df[c("Longitude", "Latitude")] <- do.call(rbind, lapply(strsplit(df$GeoLocation , "[()]"), function(col) {
            (parts <- unlist(strsplit(col[2], " ")))
          }))
          
          #Longitude
          df$Longitude<-as.double(df$Longitude)
          options(digits=16)
          
          #Latitude
          df$Latitude<-as.double(df$Latitude)
          options(digits=16)
          
          #Remove Missing Values from Latitude and Longitude
          df<-df[!is.na(df$Latitude), ]
          
          df<-df[!is.na(df$Longitude), ]
          
          return(df)
}

df <- clean_dataset(data = data)
write.csv(df, "eda_geo_spliced.csv", row.names=FALSE)

```

## Topic Distribution

```{r}
data <- df
```

```{r}
data %>%
  group_by(Topic) %>%
  summarise(count = sum(DataValue)) %>%
  ggplot(aes(x=fct_reorder(Topic, count,.desc = FALSE),y=count)) +
  geom_bar(stat = "identity",fill = "purple") +
  ggtitle("Topic Distribution") +
  coord_flip()+
  xlab("") +
  theme(panel.grid.major.x = element_blank())
```

The three diseases that we are considering are "Cardiovascular Disease", "Chronic Obstructive Pulmonary Disease" and "Diabetes".

```{r}
data <- data[data$Topic %in% c("Cardiovascular Disease", "Chronic Obstructive Pulmonary Disease", "Diabetes", "Overarching Conditions", "Chronic Kidney Disease"), ]
dim(data)
``` 

## Gender Distribution

```{r}
data_distribution <- data %>% group_by(Topic, StratificationCategoryID1, Stratification1) %>% summarise(total_count=sum(DataValue),  .groups ='drop')
View(data_distribution)
```

```{r}
data_G <- data_distribution[data_distribution$StratificationCategoryID1 %in% c("GENDER"), ]
View(data_G)
```

```{r}
ggplot(data_G, aes(x = Stratification1, y = total_count)) +
  geom_col(position = "dodge", fill = "green") +
  ggtitle("Gender Distribution") +
  xlab("") +
  ylab("Count")+
  facet_wrap(~Topic)
```

## Graph Showing the Top Cardiovascular Diseases

```{r}
df<- read.csv('https://raw.githubusercontent.com/vritansh/geochronicdisease/main/data/eda_geo_spliced.csv')

plot_geospatial_us <- function(df_disease, title, legend) {
  
  #Aggregate all values for a particular state
  df_disease <- df_disease %>% group_by(LocationDesc) %>% summarise(total_count=sum(DataValue),  .groups='drop') 
  
  #Create state and value column names for cholorpleth
  colnames(df_disease) <- c('state','value')
  
  #Preprocess data for graph
  df_disease_display <- df_disease  %>% 
    as.data.frame() %>% 
    transmute(region = tolower(`state`), value = df_disease$value)
  
  #Display choropleth
  state_choropleth(df_disease_display,
                   title = title,
                   legend = legend)
}

```


```{r}

df_disease <- df[df$Topic == 'Cardiovascular Disease', ]
plot_geospatial_us(df_disease = df_disease,title = "Mortality due to Cardiovascular disease", legend = "Count of Mortality")
```

```{r}

#Extract useful information from the complete data and save it.
save_geospatial_time <- function(data){
  
df <- data[data$DataValueType %in% c('Number'), ]
#Preprocess data here 
df$DataValue[df$DataValue==""] <- 0
#Setting Data value
df$DataValue <- as.numeric(df$DataValue)
#Add code for NVSS
df <- df[df$DataSource %in% c('NVSS'), ]
#Get all states
df <- df[df$LocationAbbr %in% c('TX','CA','FL','NY'), ]
#Get all values for location abbrevations
df_spread_geo_time <- df %>% group_by(LocationAbbr,Topic, YearEnd) %>% summarise(total_count=sum(DataValue),  .groups ='drop') 
#get df spread geo time total
df_spread_geo_time <- df_spread_geo_time[order(df_spread_geo_time$total_count),]
#Save the data to a dataset
df_spread_geo_time$YearEnd <- as.Date(as.character(df_spread_geo_time$YearEnd), format = "%Y")
#Save the data to a dataset and use later on github pages.
write.csv(df_spread_geo_time, "eda_geospatial_time.csv", row.names=FALSE)
}

save_geospatial_time(data)

```

```{r}

plot_geospatial_time <- function(df_spread_geo_time) {
g_timeseries_geo <- ggplot(df_spread_geo_time, aes( YearEnd , total_count, color=`Topic`)) +                                    
   geom_line(aes(group = `Topic`)) +
  scale_x_date(limits = c(as.Date("2011-02-01"), as.Date("2019-12-31")), date_breaks = "12 months", date_labels = "%Y") +
  facet_wrap(. ~ LocationAbbr, nrow = 4) +
  theme(axis.text.x = element_text(size = 8 , hjust = 1))
ggplotly(g_timeseries_geo)
}

#Read Data From CSV that was saved in previous step from Github and then plot 
df <- read_csv('https://raw.githubusercontent.com/vritansh/geochronicdisease/main/data/eda_geospatial_time.csv')
plot_geospatial_time(df)

```


